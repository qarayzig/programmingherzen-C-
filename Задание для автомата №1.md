1.Проверка сбалансированности скобок в выражении. Напишите программу для проверки корректности расстановки круглых, фигурных и квадратных скобок в заданной строке.
Вход. Строка с выражением, содержащим скобки (может включать и другие символы). • Выход. Вывести YES, если все типы скобок в строке корректно сбалансированы, или NO – если допущена ошибка в порядке скобок. • Требования. Для проверки использовать стек. Алгоритм должен учитывать соответствие типов скобок (например,  [ соответствует ] ) и их порядок вложенности. Программа игнорирует несвязанные символы и анализирует только скобки. При обнаружении несбалансированной скобочной структуры обработать ситуацию и вывести NO. Использование стека должно быть реализовано вручную (например, через массив или связный список), без использования сторонних коллекций.

Код: 
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

  

#define MAX 1000 // Максимальная длина входного выражения

  

// --- Стек, реализованный на массиве ---

typedef struct {

    char data[MAX];

    int top;

} Stack;

  

void init(Stack *s) {

    s->top = -1; // Инициализация вершины стека

}

  

int isEmpty(Stack *s) {

    return s->top == -1; // Проверка: пуст ли стек

}

  

int isFull(Stack *s) {

    return s->top == MAX - 1; // Проверка: переполнен ли стек

}

  

void push(Stack *s, char ch) {

    if (isFull(s)) {

        fprintf(stderr, "Error: stack overflow\n"); // Переполнение — аварийный выход

        exit(EXIT_FAILURE);

    }

    s->data[++(s->top)] = ch; // Добавление элемента в стек

}

  

char pop(Stack *s) {

    if (isEmpty(s)) {

        fprintf(stderr, "Error: stack underflow (trying to pop from empty stack)\n"); // Пустой стек — ошибка

        exit(EXIT_FAILURE);

    }

    return s->data[(s->top)--]; // Извлечение верхнего элемента

}

  

char peek(Stack *s) {

    if (isEmpty(s)) {

        return '\0'; // Если стек пуст — вернуть ноль-символ

    }

    return s->data[s->top]; // Получить верхний элемент без извлечения

}

  

// --- Проверка типа скобки ---

int isOpeningBracket(char ch) {

    return ch == '(' || ch == '[' || ch == '{'; // Открывающая скобка

}

  

int isClosingBracket(char ch) {

    return ch == ')' || ch == ']' || ch == '}'; // Закрывающая скобка

}

  

int isMatchingPair(char open, char close) {

    // Проверка: соответствует ли пара скобок

    return (open == '(' && close == ')') ||

           (open == '[' && close == ']') ||

           (open == '{' && close == '}');

}

  

// --- Основная функция проверки сбалансированности скобок ---

int isBalanced(const char *expr) {

    Stack s;

    init(&s); // Инициализация стека

  

    for (int i = 0; expr[i] != '\0'; i++) {

        char ch = expr[i];

  

        if (isOpeningBracket(ch)) {

            push(&s, ch); // Если открывающая — положить в стек

        } else if (isClosingBracket(ch)) {

            if (isEmpty(&s)) {

                printf("NO (extra closing bracket at position %d: '%c')\n", i + 1, ch); // Закрывающая без пары

                return 0;

            }

            char topChar = pop(&s); // Взять верхний элемент

            if (!isMatchingPair(topChar, ch)) {

                printf("NO (mismatched brackets at position %d: '%c' does not match '%c')\n",

                       i + 1, ch, topChar); // Скобки не совпадают по типу

                return 0;

            }

        }

        // Остальные символы игнорируются

    }

  

    if (!isEmpty(&s)) {

        printf("NO (unmatched opening brackets remain in stack)\n"); // В стеке остались лишние открывающие скобки

        return 0;

    }

  

    printf("YES\n"); // Всё корректно

    return 1;

}

  

// --- Основная функция программы ---

int main() {

    char expression[MAX];

  

    printf("Bracket balance checker\n");

    printf("Enter an expression (type 'exit' to quit):\n");

  

    while (1) {

        printf("\n> ");

        if (!fgets(expression, MAX, stdin)) break;

  

        expression[strcspn(expression, "\n")] = '\0'; // Удалить символ новой строки

  

        if (strcmp(expression, "exit") == 0) {

            break; // Завершить программу по команде

        }

  

        isBalanced(expression); // Проверить выражение

    }

  

    printf("Exiting program.\n");

    return 0;
   }

Структуры и поля:

Stack           — структура          — Стек, реализованный через массив
data            — char[MAX]          — Массив символов, хранящий содержимое стека
top             — int                — Индекс вершины стека (верхний элемент)

Функции: 

init            — void               — Инициализация стека (обнуление top)
isEmpty         — int                — Проверка: пуст ли стек
isFull          — int                — Проверка: полон ли стек
push            — void               — Добавление символа в стек
pop             — char               — Удаление и возврат символа с вершины стека
peek            — char               — Возврат верхнего символа без удаления
isOpeningBracket — int              — Проверка: является ли символ открывающей скобкой
isClosingBracket — int              — Проверка: является ли символ закрывающей скобкой
isMatchingPair  — int                — Проверка: соответствуют ли открывающая и закрывающая скобки
isBalanced      — int                — Основная функция проверки сбалансированности скобок
main            — int                — Главная функция программы (ввод/вывод)

Переменные:

expression      — char[MAX]          — Строка с введённым выражением для проверки
s               — Stack              — Экземпляр структуры стека
ch              — char               — Текущий символ из строки
topChar         — char               — Символ, извлечённый из вершины стека
i               — int                — Индекс символа в строке при проходе по выражению

Результат кода:

![[Pasted image 20250620212112.png]]

Вывод: 
Назначение: Проверка сбалансированности скобок (), {}, [] с помощью самодельного стека на массиве.

Принцип работы:

При открывающей скобке — добавить в стек.

При закрывающей — сравнить с верхней из стека.

Если стек в конце пуст — выражение корректно.

Улучшения: обработка ошибок, сообщения о позиции ошибки, многократный ввод, ручной ввод/выход.


